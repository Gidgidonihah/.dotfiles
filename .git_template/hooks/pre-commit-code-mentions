#!/usr/bin/env python
import sys
from subprocess import Popen, PIPE

try:
    from termcolor import colored
except ImportError:
    def colored(text, color=None, on_color=None, attrs=None):
        return text


def main():
    sys.stdin = open('/dev/tty')  # we would like to offer input, please.
    pattern = '\@\w+'  # simple regex to match all mentions @bbarker, @yourmom, @buddah

    gitcmd = "git diff --staged --color -G %s --exit-code" % pattern
    code, res, _ = run(gitcmd)

    if code:
        get_response(pattern)
    else:
        sys.exit(0)


def get_response(pattern):
    response = None
    while response is None or response == '' or response not in 'YyNnQqRrh?':

        string = 'The current commit contains code mentions (e.g. @bbarker). Continue? [y,n,r,?]'
        response = raw_input(colored(string, 'magenta'))

        if response != '':
            if response in 'Yy':
                sys.exit(0)
            elif response in 'NnQq':
                print colored('Git commit aborted.', 'red')
                sys.exit(1)
            elif response in 'Rr':
                print colored('showing', 'yellow')
                response = None
                gitcmd = "git diff --staged --color -G %s --exit-code" % pattern
                code, res, _ = run(gitcmd)
                for line in res:
                    print line
            elif response in 'h?':
                print colored("y - Continue with the commit.\nn - Stop the commit.\nr - Review the matching diff.\n? - Show this help.\n", 'yellow')
                response = None


# borrowed from https://bitbucket.org/tarek/flake8
def run(command, raw_output=False, decode=True):
    p = Popen(command.split(), stdout=PIPE, stderr=PIPE)
    (stdout, stderr) = p.communicate()
    # On python 3, subprocess.Popen returns bytes objects which expect
    # endswith to be given a bytes object or a tuple of bytes but not native
    # string objects. This is simply less mysterious than using b'.py' in the
    # endswith method. That should work but might still fail horribly.
    if hasattr(stdout, 'decode'):
        if decode:
            stdout = stdout.decode()
    if hasattr(stderr, 'decode'):
        if decode:
            stderr = stderr.decode()
    if not raw_output:
        stdout = [line.strip() for line in stdout.splitlines()]
        stderr = [line.strip() for line in stderr.splitlines()]
    return (p.returncode, stdout, stderr)

if __name__ == "__main__":
    main()
